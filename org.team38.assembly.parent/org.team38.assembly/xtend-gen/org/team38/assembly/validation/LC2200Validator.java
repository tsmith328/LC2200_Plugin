/**
 * generated by Xtext 2.9.1
 */
package org.team38.assembly.validation;

import com.google.common.base.Objects;
import java.util.HashMap;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.team38.assembly.LabelHandler;
import org.team38.assembly.lC2200.IInstruction;
import org.team38.assembly.lC2200.Instruction;
import org.team38.assembly.lC2200.LC2200Package;
import org.team38.assembly.lC2200.LabelBeg;
import org.team38.assembly.lC2200.LabelEnd;
import org.team38.assembly.lC2200.Line;
import org.team38.assembly.lC2200.Program;
import org.team38.assembly.lC2200.WordDirective;
import org.team38.assembly.validation.AbstractLC2200Validator;

/**
 * Provide various semantic checks for written LC-2200 code.
 */
@SuppressWarnings("all")
public class LC2200Validator extends AbstractLC2200Validator {
  /**
   * Warning Codes
   */
  public final static String DECIMAL_IMMEDIATE_VALUE = "Immediate Value is decimal";
  
  public final static String EXTREME_IMMEDIATE_VALUE = "Immediate Value is too extreme";
  
  public final static String INVALID_LABEL = "Label is invalid";
  
  public final static String OUT_OF_RANGE_LABEL = "Label is out of range";
  
  public final static String DUPLICATE_LABEL = "Label already exists";
  
  /**
   * Checks whether I-instruction immediate values can be
   * represented in 5 bits (for 16-bit instructions)
   * 
   * @param instr - The IInstruction to check
   */
  @Check
  public void checkInstructionImmediate(final IInstruction instr) {
    EObject _i_opcode = instr.getI_opcode();
    EClass _eClass = _i_opcode.eClass();
    String _name = _eClass.getName();
    boolean _equals = _name.equals("IInstructionLabelTrans");
    if (_equals) {
      return;
    }
    String imm = instr.getImm();
    int immInt = 0;
    try {
      int _indexOf = imm.indexOf("0x");
      boolean _notEquals = (_indexOf != (-1));
      if (_notEquals) {
        String _substring = imm.substring(2);
        int _parseInt = Integer.parseInt(_substring, 16);
        immInt = _parseInt;
      } else {
        int _parseInt_1 = Integer.parseInt(imm);
        immInt = _parseInt_1;
      }
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        this.warning("Immediate values should be hex or decimal integers", LC2200Package.Literals.IINSTRUCTION__IMM, LC2200Validator.DECIMAL_IMMEDIATE_VALUE);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    if ((immInt < (-16))) {
      this.warning("Signed 5 bit immediate values should be between -16 and 15", LC2200Package.Literals.IINSTRUCTION__IMM, LC2200Validator.EXTREME_IMMEDIATE_VALUE, "-16");
    }
    if ((immInt > 15)) {
      this.warning("Signed 5 bit immediate values should be between -16 and 15", LC2200Package.Literals.IINSTRUCTION__IMM, LC2200Validator.EXTREME_IMMEDIATE_VALUE, "15");
    }
  }
  
  /**
   * Check whether word immediate values can fit
   * within 16 bits.
   * 
   * @param word - The word directive to check
   */
  @Check
  public void checkWordImmediate(final WordDirective word) {
    String imm = word.getImm();
    int immInt = 0;
    try {
      int _indexOf = imm.indexOf("0x");
      boolean _notEquals = (_indexOf != (-1));
      if (_notEquals) {
        String _substring = imm.substring(2);
        int _parseInt = Integer.parseInt(_substring, 16);
        immInt = _parseInt;
      } else {
        int _parseInt_1 = Integer.parseInt(imm);
        immInt = _parseInt_1;
      }
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        this.warning("Immediate values should be integers", LC2200Package.Literals.WORD_DIRECTIVE__IMM, LC2200Validator.DECIMAL_IMMEDIATE_VALUE);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    if ((immInt < (-65536))) {
      this.warning("Signed 16 bit immediate values should be between -65536 and 65535", LC2200Package.Literals.WORD_DIRECTIVE__IMM, LC2200Validator.EXTREME_IMMEDIATE_VALUE, "-65536");
    }
    if ((immInt > 65535)) {
      this.warning("Signed 16 bit immediate values should be between -65536 and 65535", LC2200Package.Literals.WORD_DIRECTIVE__IMM, LC2200Validator.EXTREME_IMMEDIATE_VALUE, "65535");
    }
  }
  
  /**
   * Check whether the offset to a label in a branching
   * I-type instruction can fit into the 5 bit immediate.
   * 
   * @param instr - The IInstruction to check
   */
  @Check
  public void checkLabelIsValid(final IInstruction instr) {
    EObject _i_opcode = instr.getI_opcode();
    EClass _eClass = _i_opcode.eClass();
    String _name = _eClass.getName();
    boolean _equals = _name.equals("IInstructionLabelTrans");
    if (_equals) {
      LabelEnd labelTrans = instr.getLabel();
      String label = labelTrans.getLabel();
      EObject root = ((EObject) instr);
      EObject _eContainer = instr.eContainer();
      Instruction parent = ((Instruction) _eContainer);
      while ((!Objects.equal(root.eContainer(), null))) {
        EObject _eContainer_1 = root.eContainer();
        root = _eContainer_1;
      }
      EClass _eClass_1 = root.eClass();
      String _name_1 = _eClass_1.getName();
      boolean _equals_1 = _name_1.equals("Program");
      if (_equals_1) {
        HashMap<String, Integer> labelTable = LabelHandler.populateLabels(((Program) root));
        Integer _get = labelTable.get(label);
        boolean _equals_2 = Objects.equal(_get, null);
        if (_equals_2) {
          Set<String> _keySet = labelTable.keySet();
          this.warning("Label does not exist", LC2200Package.Literals.IINSTRUCTION__LABEL, LC2200Validator.INVALID_LABEL, ((String[])Conversions.unwrapArray(_keySet, String.class)));
        } else {
          Integer _get_1 = labelTable.get(label);
          boolean _notEquals = ((_get_1).intValue() != (-1));
          if (_notEquals) {
            EList<EObject> lines = ((Program) root).getLines();
            int offset = 0;
            boolean found = false;
            for (int i = 0; ((i < ((Object[])Conversions.unwrapArray(lines, Object.class)).length) && (!found)); i++) {
              {
                EObject _get_2 = lines.get(i);
                boolean _equals_3 = parent.equals(_get_2);
                if (_equals_3) {
                  found = true;
                  Integer _get_3 = labelTable.get(label);
                  int dif = ((_get_3).intValue() - offset);
                  if (((dif > 15) || (dif < (-16)))) {
                    this.warning("Label offset cannot fit into 5 bits", LC2200Package.Literals.IINSTRUCTION__LABEL, LC2200Validator.OUT_OF_RANGE_LABEL);
                  }
                }
                EObject _get_4 = lines.get(i);
                EClass _eClass_2 = _get_4.eClass();
                String _name_2 = _eClass_2.getName();
                boolean _equals_4 = _name_2.equals("LineEnd");
                boolean _not = (!_equals_4);
                if (_not) {
                  offset++;
                }
              }
            }
          }
        }
      }
    }
  }
  
  /**
   * Check whether there are duplicate label declarations
   * 
   * @param line - The line to check
   */
  @Check
  public void checkDuplicateLabel(final Line line) {
    boolean _or = false;
    EClass _eClass = line.eClass();
    String _name = _eClass.getName();
    boolean _equals = _name.equals("Instruction");
    if (_equals) {
      _or = true;
    } else {
      EClass _eClass_1 = line.eClass();
      String _name_1 = _eClass_1.getName();
      boolean _equals_1 = _name_1.equals("Directive");
      _or = _equals_1;
    }
    if (_or) {
      LabelBeg labelBeg = line.getLabel();
      String label = labelBeg.getLabel();
      String _replaceAll = label.replaceAll(":", "");
      label = _replaceAll;
      EObject root = ((EObject) line);
      while ((!Objects.equal(root.eContainer(), null))) {
        EObject _eContainer = root.eContainer();
        root = _eContainer;
      }
      EClass _eClass_2 = root.eClass();
      String _name_2 = _eClass_2.getName();
      boolean _equals_2 = _name_2.equals("Program");
      if (_equals_2) {
        HashMap<String, Integer> labelTable = LabelHandler.populateLabels(((Program) root));
        Integer _get = labelTable.get(label);
        boolean _equals_3 = ((_get).intValue() == (-1));
        if (_equals_3) {
          this.warning("Duplicate label", LC2200Package.Literals.LINE__LABEL, LC2200Validator.DUPLICATE_LABEL);
        }
      }
    }
  }
}
