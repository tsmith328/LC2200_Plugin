/**
 * generated by Xtext 2.9.1
 */
package org.team38.assembly.generator;

import com.google.common.base.Objects;
import java.util.HashMap;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.team38.assembly.LabelHandler;
import org.team38.assembly.lC2200.Directive;
import org.team38.assembly.lC2200.IInstruction;
import org.team38.assembly.lC2200.IInstructionImmTrans;
import org.team38.assembly.lC2200.IInstructionLabelTrans;
import org.team38.assembly.lC2200.IInstructionOffsetTrans;
import org.team38.assembly.lC2200.Instruction;
import org.team38.assembly.lC2200.JInstruction;
import org.team38.assembly.lC2200.JInstructionTrans;
import org.team38.assembly.lC2200.LADirective;
import org.team38.assembly.lC2200.LabelEnd;
import org.team38.assembly.lC2200.NOOPDirective;
import org.team38.assembly.lC2200.OInstruction;
import org.team38.assembly.lC2200.Program;
import org.team38.assembly.lC2200.RInstruction;
import org.team38.assembly.lC2200.RInstructionTrans;
import org.team38.assembly.lC2200.RegTrans;
import org.team38.assembly.lC2200.WordDirective;

/**
 * Generates binary output from the assembled instructions
 */
@SuppressWarnings("all")
public class LC2200Generator extends AbstractGenerator {
  /**
   * A buffer which will accumulate the pretty print generated binary
   */
  private StringBuffer assembledOutput;
  
  /**
   * A buffer which will accumulate the 16 bit generated hex
   */
  private StringBuffer hex16Output;
  
  /**
   * A buffer which will accumulate the 32 bit generated hex
   */
  private StringBuffer hex32Output;
  
  /**
   * A hash map storing the location of all labels for calculating branches
   */
  private HashMap<String, Integer> labelTable;
  
  /**
   * An integer used to keep track of current line being assembled
   */
  private int offset;
  
  /**
   * The name of the generated file
   */
  private String filename;
  
  /**
   * doGenerate is called when user saves their assembly code and will
   * save generated binary output to a file. The code is scanned to obtain
   * label locations, and then compiled line by line.
   * 
   * @param resource - Used to obtain the parse tree
   * @param fsa - Used to save the file to disk
   * @param context - Unused
   */
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    StringBuffer _stringBuffer = new StringBuffer();
    this.assembledOutput = _stringBuffer;
    StringBuffer _stringBuffer_1 = new StringBuffer();
    this.hex16Output = _stringBuffer_1;
    StringBuffer _stringBuffer_2 = new StringBuffer();
    this.hex32Output = _stringBuffer_2;
    this.offset = 0;
    EList<EObject> _contents = resource.getContents();
    EObject e_root = _contents.get(0);
    boolean _notEquals = (!Objects.equal(e_root, null));
    if (_notEquals) {
      EClass _eClass = e_root.eClass();
      String _name = _eClass.getName();
      boolean _equals = _name.equals("Program");
      if (_equals) {
        HashMap<String, Integer> _populateLabels = LabelHandler.populateLabels(((Program) e_root));
        this.labelTable = _populateLabels;
        this.compileProgram(((Program) e_root));
      }
    }
    String _string = resource.toString();
    this.filename = _string;
    int _lastIndexOf = this.filename.lastIndexOf("/");
    int _length = this.filename.length();
    int _minus = (_length - 2);
    String _substring = this.filename.substring(_lastIndexOf, _minus);
    String binFile = (_substring + "bin");
    int _lastIndexOf_1 = this.filename.lastIndexOf("/");
    int _length_1 = this.filename.length();
    int _minus_1 = (_length_1 - 3);
    String _substring_1 = this.filename.substring(_lastIndexOf_1, _minus_1);
    String hex16File = (_substring_1 + "-16.lc");
    int _lastIndexOf_2 = this.filename.lastIndexOf("/");
    int _length_2 = this.filename.length();
    int _minus_2 = (_length_2 - 3);
    String _substring_2 = this.filename.substring(_lastIndexOf_2, _minus_2);
    String hex32File = (_substring_2 + "-32.lc");
    String _string_1 = this.assembledOutput.toString();
    String _trim = _string_1.trim();
    fsa.generateFile(binFile, _trim);
    String _string_2 = this.hex16Output.toString();
    String _trim_1 = _string_2.trim();
    fsa.generateFile(hex16File, _trim_1);
    String _string_3 = this.hex32Output.toString();
    String _trim_2 = _string_3.trim();
    fsa.generateFile(hex32File, _trim_2);
  }
  
  /**
   * Handle the root of the parse tree. Call appropriate
   * method for Directives and Instructions respectively
   * 
   * @param root - The root of the parse tree
   */
  private void compileProgram(final Program root) {
    EList<EObject> nodes = root.eContents();
    for (final EObject node : nodes) {
      EClass _eClass = node.eClass();
      String _name = _eClass.getName();
      boolean _equals = _name.equals("Directive");
      if (_equals) {
        this.compileDirective(((Directive) node));
        this.offset++;
      } else {
        EClass _eClass_1 = node.eClass();
        String _name_1 = _eClass_1.getName();
        boolean _equals_1 = _name_1.equals("Instruction");
        if (_equals_1) {
          this.compileInstruction(((Instruction) node));
          this.offset++;
        } else {
          EClass _eClass_2 = node.eClass();
          String _name_2 = _eClass_2.getName();
          boolean _equals_2 = _name_2.equals("LineEnd");
          if (_equals_2) {
            this.assembledOutput.append("\n");
          }
        }
      }
    }
  }
  
  /**
   * Handle the Directive node of the parse tree. Call the
   * method for NOOPDirective, WordDirective, and LADirective
   * node types.
   * 
   * @param dir - The directive node of the parse tree
   */
  private StringBuffer compileDirective(final Directive dir) {
    StringBuffer _xblockexpression = null;
    {
      EObject dirType = dir.getDirective();
      StringBuffer _xifexpression = null;
      EClass _eClass = dirType.eClass();
      String _name = _eClass.getName();
      boolean _equals = _name.equals("NOOPDirective");
      if (_equals) {
        _xifexpression = this.compileNOOP(((NOOPDirective) dirType));
      } else {
        StringBuffer _xifexpression_1 = null;
        EClass _eClass_1 = dirType.eClass();
        String _name_1 = _eClass_1.getName();
        boolean _equals_1 = _name_1.equals("WordDirective");
        if (_equals_1) {
          _xifexpression_1 = this.compileWord(((WordDirective) dirType));
        } else {
          StringBuffer _xifexpression_2 = null;
          EClass _eClass_2 = dirType.eClass();
          String _name_2 = _eClass_2.getName();
          boolean _equals_2 = _name_2.equals("LADirective");
          if (_equals_2) {
            _xifexpression_2 = this.compileLA(((LADirective) dirType));
          }
          _xifexpression_1 = _xifexpression_2;
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  /**
   * Handle the Instruction node of the parse tree. Call the method corresponding
   * to the instruction type.
   * 
   * @param instr - The instruction node of the parse tree
   */
  private StringBuffer compileInstruction(final Instruction instr) {
    StringBuffer _xblockexpression = null;
    {
      EObject instrType = instr.getInstruction();
      StringBuffer _xifexpression = null;
      EClass _eClass = instrType.eClass();
      String _name = _eClass.getName();
      boolean _equals = _name.equals("IInstruction");
      if (_equals) {
        _xifexpression = this.compileIInstruction(((IInstruction) instrType));
      } else {
        StringBuffer _xifexpression_1 = null;
        EClass _eClass_1 = instrType.eClass();
        String _name_1 = _eClass_1.getName();
        boolean _equals_1 = _name_1.equals("RInstruction");
        if (_equals_1) {
          _xifexpression_1 = this.compileRInstruction(((RInstruction) instrType));
        } else {
          StringBuffer _xifexpression_2 = null;
          EClass _eClass_2 = instrType.eClass();
          String _name_2 = _eClass_2.getName();
          boolean _equals_2 = _name_2.equals("JInstruction");
          if (_equals_2) {
            _xifexpression_2 = this.compileJInstruction(((JInstruction) instrType));
          } else {
            StringBuffer _xifexpression_3 = null;
            EClass _eClass_3 = instrType.eClass();
            String _name_3 = _eClass_3.getName();
            boolean _equals_3 = _name_3.equals("OInstruction");
            if (_equals_3) {
              _xifexpression_3 = this.compileOInstruction(((OInstruction) instrType));
            }
            _xifexpression_2 = _xifexpression_3;
          }
          _xifexpression_1 = _xifexpression_2;
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  /**
   * Generate the binary output for an LADirective node. Use helper
   * methods to convert labels/registers/opcode to binary form.
   * 
   * @param la - The node to generate binary for
   */
  private StringBuffer compileLA(final LADirective la) {
    StringBuffer _xblockexpression = null;
    {
      LabelEnd labelTrans = la.getLabel();
      RegTrans regTrans = la.getReg();
      String reg = regTrans.getReg();
      String immBin16 = "";
      String immBin32 = "";
      String label = "";
      boolean _notEquals = (!Objects.equal(labelTrans, null));
      if (_notEquals) {
        String _label = labelTrans.getLabel();
        label = _label;
        boolean _notEquals_1 = (!Objects.equal(label, null));
        if (_notEquals_1) {
          Integer labelLine = this.labelTable.get(label);
          boolean _notEquals_2 = (!Objects.equal(labelLine, null));
          if (_notEquals_2) {
            String _string = Integer.toString((labelLine).intValue());
            String _immToBinary = this.immToBinary(_string, 5);
            immBin16 = _immToBinary;
            String _string_1 = Integer.toString((labelLine).intValue());
            String _immToBinary_1 = this.immToBinary(_string_1, 20);
            immBin32 = _immToBinary_1;
          } else {
            immBin16 = "xxxxx";
            immBin32 = "xxxxxxxxxxxxxxxxxxxx";
          }
        } else {
          label = "";
        }
      }
      String reg1Bin = this.regToBinary(reg);
      String reg2Bin = this.regToBinary("$zero");
      String opBin16 = this.opToBinary16("addi");
      String opBin32 = this.opToBinary32("addi");
      boolean _notEquals_3 = (!Objects.equal(opBin16, ""));
      if (_notEquals_3) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("OP: ");
        _builder.append(opBin16, "");
        _builder.append("  RX: ");
        _builder.append(reg1Bin, "");
        _builder.append("  RY: ");
        _builder.append(reg2Bin, "");
        _builder.append("  IM: ");
        _builder.append(immBin16, "");
        this.assembledOutput.append(_builder);
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append(opBin16, "");
        _builder_1.append(reg1Bin, "");
        _builder_1.append(reg2Bin, "");
        _builder_1.append(immBin16, "");
        String hex16 = this.binToHex(_builder_1.toString());
        this.hex16Output.append((hex16 + " "));
      } else {
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("Not supported in 16-bit architecture");
        this.assembledOutput.append(_builder_2);
      }
      StringConcatenation _builder_3 = new StringConcatenation();
      _builder_3.append(opBin32, "");
      _builder_3.append(reg1Bin, "");
      _builder_3.append(reg2Bin, "");
      _builder_3.append(immBin32, "");
      String hex32 = this.binToHex(_builder_3.toString());
      _xblockexpression = this.hex32Output.append((hex32 + " "));
    }
    return _xblockexpression;
  }
  
  /**
   * Generate the binary output for the NOOP node.
   * 
   * @param noop - The noop node
   */
  private StringBuffer compileNOOP(final NOOPDirective noop) {
    StringBuffer _xblockexpression = null;
    {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("NOOP: 0000000000000000");
      this.assembledOutput.append(_builder);
      this.hex16Output.append("0000 ");
      _xblockexpression = this.hex32Output.append("00000000 ");
    }
    return _xblockexpression;
  }
  
  /**
   * Generate the binary for the WordDirective node.
   * Use a helper method to convert the immediate to binary.
   * 
   * @param word - The word node
   */
  private StringBuffer compileWord(final WordDirective word) {
    StringBuffer _xblockexpression = null;
    {
      String wordImm = word.getImm();
      String wordImmBin16 = this.immToBinary(wordImm, 16);
      String wordImmBin32 = this.immToBinary(wordImm, 32);
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("WORD: ");
      _builder.append(wordImmBin16, "");
      this.assembledOutput.append(_builder);
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(wordImmBin16, "");
      String hex16 = this.binToHex(_builder_1.toString());
      this.hex16Output.append((hex16 + " "));
      StringConcatenation _builder_2 = new StringConcatenation();
      _builder_2.append(wordImmBin32, "");
      String hex32 = this.binToHex(_builder_2.toString());
      _xblockexpression = this.hex32Output.append((hex32 + " "));
    }
    return _xblockexpression;
  }
  
  /**
   * Generate the binary for the I-type instruction node. Use
   * helper methods to convert registers/opcode/immediate to binary.
   * 
   * @param iInstr - The IInstruction node
   */
  private StringBuffer compileIInstruction(final IInstruction iInstr) {
    StringBuffer _xblockexpression = null;
    {
      String op = "";
      EObject opTrans = iInstr.getI_opcode();
      if ((opTrans instanceof IInstructionImmTrans)) {
        String _i_opcode = ((IInstructionImmTrans) opTrans).getI_opcode();
        op = _i_opcode;
      } else {
        if ((opTrans instanceof IInstructionOffsetTrans)) {
          String _i_opcode_1 = ((IInstructionOffsetTrans) opTrans).getI_opcode();
          op = _i_opcode_1;
        } else {
          if ((opTrans instanceof IInstructionLabelTrans)) {
            String _i_opcode_2 = ((IInstructionLabelTrans) opTrans).getI_opcode();
            op = _i_opcode_2;
          }
        }
      }
      RegTrans reg1Trans = iInstr.getReg1();
      RegTrans reg2Trans = iInstr.getReg2();
      LabelEnd labelTrans = iInstr.getLabel();
      String reg1 = ((RegTrans) reg1Trans).getReg();
      String reg2 = ((RegTrans) reg2Trans).getReg();
      String imm = iInstr.getImm();
      String _string = op.toString();
      String opBin16 = this.opToBinary16(_string);
      String _string_1 = op.toString();
      String opBin32 = this.opToBinary32(_string_1);
      String _string_2 = reg1.toString();
      String reg1Bin = this.regToBinary(_string_2);
      String _string_3 = reg2.toString();
      String reg2Bin = this.regToBinary(_string_3);
      String immBin16 = "";
      String immBin32 = "";
      boolean _equals = op.equals("beq");
      if (_equals) {
        boolean _notEquals = (!Objects.equal(labelTrans, null));
        if (_notEquals) {
          String label = labelTrans.getLabel();
          boolean _notEquals_1 = (!Objects.equal(label, null));
          if (_notEquals_1) {
            Integer labelLine = this.labelTable.get(label);
            boolean _notEquals_2 = (!Objects.equal(labelLine, null));
            if (_notEquals_2) {
              int dif = ((labelLine).intValue() - this.offset);
              String _string_4 = Integer.toString(dif);
              String _immToBinary = this.immToBinary(_string_4, 5);
              immBin16 = _immToBinary;
              String _string_5 = Integer.toString(dif);
              String _immToBinary_1 = this.immToBinary(_string_5, 20);
              immBin32 = _immToBinary_1;
            } else {
              immBin16 = "xxxxx";
              immBin32 = "xxxxxxxxxxxxxxxxxxxx";
            }
          }
        }
      } else {
        String _immToBinary_2 = this.immToBinary(imm, 5);
        immBin16 = _immToBinary_2;
        String _immToBinary_3 = this.immToBinary(imm, 20);
        immBin32 = _immToBinary_3;
      }
      boolean _notEquals_3 = (!Objects.equal(opBin16, ""));
      if (_notEquals_3) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("OP: ");
        _builder.append(opBin16, "");
        _builder.append("  RX: ");
        _builder.append(reg1Bin, "");
        _builder.append("  RY: ");
        _builder.append(reg2Bin, "");
        _builder.append("  IM: ");
        _builder.append(immBin16, "");
        this.assembledOutput.append(_builder);
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append(opBin16, "");
        _builder_1.append(reg1Bin, "");
        _builder_1.append(reg2Bin, "");
        _builder_1.append(immBin16, "");
        String hex16 = this.binToHex(_builder_1.toString());
        this.hex16Output.append((hex16 + " "));
      } else {
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("Not supported in 16-bit architecture");
        this.assembledOutput.append(_builder_2);
      }
      StringConcatenation _builder_3 = new StringConcatenation();
      _builder_3.append(opBin32, "");
      _builder_3.append(reg1Bin, "");
      _builder_3.append(reg2Bin, "");
      _builder_3.append(immBin32, "");
      String hex32 = this.binToHex(_builder_3.toString());
      _xblockexpression = this.hex32Output.append((hex32 + " "));
    }
    return _xblockexpression;
  }
  
  /**
   * Generate the binary for the R-type instruction. Use
   * helper methods to convert registers/opcode/immediate to binary.
   * 
   * @param rInstr - The RInstruction node
   */
  private StringBuffer compileRInstruction(final RInstruction rInstr) {
    StringBuffer _xblockexpression = null;
    {
      RInstructionTrans opTrans = rInstr.getR_opcode();
      RegTrans reg1Trans = rInstr.getReg1();
      RegTrans reg2Trans = rInstr.getReg2();
      RegTrans reg3Trans = rInstr.getReg3();
      String op = ((RInstructionTrans) opTrans).getR_opcode();
      String reg1 = ((RegTrans) reg1Trans).getReg();
      String reg2 = ((RegTrans) reg2Trans).getReg();
      String reg3 = ((RegTrans) reg3Trans).getReg();
      String _string = op.toString();
      String opBin16 = this.opToBinary16(_string);
      String _string_1 = op.toString();
      String opBin32 = this.opToBinary32(_string_1);
      String _string_2 = reg1.toString();
      String reg1Bin = this.regToBinary(_string_2);
      String _string_3 = reg2.toString();
      String reg2Bin = this.regToBinary(_string_3);
      String _string_4 = reg3.toString();
      String reg3Bin = this.regToBinary(_string_4);
      boolean _notEquals = (!Objects.equal(opBin16, ""));
      if (_notEquals) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("OP: ");
        _builder.append(opBin16, "");
        _builder.append("  RX: ");
        _builder.append(reg1Bin, "");
        _builder.append("  RY: ");
        _builder.append(reg2Bin, "");
        _builder.append("  RZ: ");
        _builder.append(reg3Bin, "");
        _builder.append("  UNUSED: 0");
        this.assembledOutput.append(_builder);
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append(opBin16, "");
        _builder_1.append(reg1Bin, "");
        _builder_1.append(reg2Bin, "");
        _builder_1.append(reg3Bin, "");
        _builder_1.append("0");
        String hex16 = this.binToHex(_builder_1.toString());
        this.hex16Output.append((hex16 + " "));
      } else {
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("Not supported in 16-bit architecture");
        this.assembledOutput.append(_builder_2);
      }
      StringConcatenation _builder_3 = new StringConcatenation();
      _builder_3.append(opBin32, "");
      _builder_3.append(reg1Bin, "");
      _builder_3.append(reg2Bin, "");
      _builder_3.append("0000000000000000");
      _builder_3.append(reg3Bin, "");
      String hex32 = this.binToHex(_builder_3.toString());
      _xblockexpression = this.hex32Output.append((hex32 + " "));
    }
    return _xblockexpression;
  }
  
  /**
   * Generate the binary for the J-type instruction. Use
   * helper methods to convert registers/opcode/immediate to binary.
   * 
   * @param jInstr - The JInstruction node
   */
  private StringBuffer compileJInstruction(final JInstruction jInstr) {
    StringBuffer _xblockexpression = null;
    {
      JInstructionTrans opTrans = jInstr.getJ_opcode();
      RegTrans reg1Trans = jInstr.getReg1();
      RegTrans reg2Trans = jInstr.getReg2();
      String op = ((JInstructionTrans) opTrans).getJ_opcode();
      String reg1 = ((RegTrans) reg1Trans).getReg();
      String reg2 = ((RegTrans) reg2Trans).getReg();
      String _string = op.toString();
      String opBin16 = this.opToBinary16(_string);
      String _string_1 = op.toString();
      String opBin32 = this.opToBinary32(_string_1);
      String _string_2 = reg1.toString();
      String reg1Bin = this.regToBinary(_string_2);
      String _string_3 = reg2.toString();
      String reg2Bin = this.regToBinary(_string_3);
      boolean _notEquals = (!Objects.equal(opBin16, ""));
      if (_notEquals) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("OP: ");
        _builder.append(opBin16, "");
        _builder.append("  RX: ");
        _builder.append(reg1Bin, "");
        _builder.append("  RY: ");
        _builder.append(reg2Bin, "");
        _builder.append("  Unused: 00000");
        this.assembledOutput.append(_builder);
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append(opBin16, "");
        _builder_1.append(reg1Bin, "");
        _builder_1.append(reg2Bin, "");
        _builder_1.append("00000");
        String hex16 = this.binToHex(_builder_1.toString());
        this.hex16Output.append((hex16 + " "));
      } else {
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("Not supported in 16-bit architecture");
        this.assembledOutput.append(_builder_2);
      }
      StringConcatenation _builder_3 = new StringConcatenation();
      _builder_3.append(opBin32, "");
      _builder_3.append(reg1Bin, "");
      _builder_3.append(reg2Bin, "");
      _builder_3.append("00000000000000000000");
      String hex32 = this.binToHex(_builder_3.toString());
      _xblockexpression = this.hex32Output.append((hex32 + " "));
    }
    return _xblockexpression;
  }
  
  /**
   * Generate the binary for the O-type instruction. Use
   * helper methods to convert the opcode to binary.
   * 
   * @param oInstr - The OInstruction node
   */
  private StringBuffer compileOInstruction(final OInstruction oInstr) {
    StringBuffer _xblockexpression = null;
    {
      String op = oInstr.getO_opcode();
      String opBin16 = this.opToBinary16(op);
      String opBin32 = this.opToBinary32(op);
      boolean _notEquals = (!Objects.equal(opBin16, ""));
      if (_notEquals) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("OP: ");
        _builder.append(opBin16, "");
        _builder.append("  UNUSED: 000000000000");
        this.assembledOutput.append(_builder);
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append(opBin16, "");
        _builder_1.append("0000000000000");
        String hex16 = this.binToHex(_builder_1.toString());
        this.hex16Output.append((hex16 + " "));
      } else {
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("Not supported in 16-bit architecture");
        this.assembledOutput.append(_builder_2);
      }
      StringConcatenation _builder_3 = new StringConcatenation();
      _builder_3.append(opBin32, "");
      _builder_3.append("0000000000000000000000000000");
      String hex32 = this.binToHex(_builder_3.toString());
      _xblockexpression = this.hex32Output.append((hex32 + " "));
    }
    return _xblockexpression;
  }
  
  /**
   * Helper method to convert opcodes into 32-bit binary form.
   * 
   * @param op - The opcode to be converted to binary
   */
  private String opToBinary32(final String op) {
    switch (op) {
      case "add":
        return "0000";
      case "nand":
        return "0001";
      case "addi":
        return "0010";
      case "lw":
        return "0011";
      case "sw":
        return "0100";
      case "beq":
        return "0101";
      case "jalr":
        return "0110";
      case "halt":
        return "0111";
      case "ei":
        return "1100";
      case "di":
        return "1101";
      case "reti":
        return "1100";
      case "boni":
        return "1101";
      case "bonj":
        return "1110";
      case "bonr":
        return "1000";
      case "bono":
        return "1001";
      default:
        return "";
    }
  }
  
  /**
   * Helper method to convert opcodes into 16-bit binary form.
   * 
   * @param op - The opcode to be converted to binary
   */
  private String opToBinary16(final String op) {
    switch (op) {
      case "add":
        return "000";
      case "nand":
        return "001";
      case "addi":
        return "010";
      case "lw":
        return "011";
      case "sw":
        return "100";
      case "beq":
        return "101";
      case "jalr":
        return "110";
      case "halt":
        return "111";
      default:
        return "";
    }
  }
  
  /**
   * Helper method to convert registers to binary.
   * 
   * @param reg - The register to convert to binary
   */
  private String regToBinary(final String reg) {
    switch (reg) {
      case "$zero":
        return "0000";
      case "$at":
        return "0001";
      case "$v0":
        return "0010";
      case "$a0":
        return "0011";
      case "$a1":
        return "0100";
      case "$a2":
        return "0101";
      case "$t0":
        return "0110";
      case "$t1":
        return "0111";
      case "$t2":
        return "1000";
      case "$s0":
        return "1001";
      case "$s1":
        return "1010";
      case "$s2":
        return "1011";
      case "$k0":
        return "1100";
      case "$sp":
        return "1101";
      case "$fp":
        return "1110";
      case "$ra":
        return "1111";
      default:
        return "";
    }
  }
  
  /**
   * Helper method to convert immediate values into a binary string.
   * 
   * @param imm - The immediate to convert
   * @param bitLength - The length of the final bit string
   */
  private String immToBinary(final String imm, final int bitLength) {
    String immBin = "";
    try {
      long immLong = 0l;
      int _indexOf = imm.indexOf("0x");
      boolean _notEquals = (_indexOf != (-1));
      if (_notEquals) {
        String _substring = imm.substring(2);
        long _parseLong = Long.parseLong(_substring, 16);
        immLong = _parseLong;
      } else {
        long _parseLong_1 = Long.parseLong(imm);
        immLong = _parseLong_1;
      }
      String _binaryString = Long.toBinaryString(immLong);
      immBin = _binaryString;
    } catch (final Throwable _t) {
      if (_t instanceof NumberFormatException) {
        final NumberFormatException e = (NumberFormatException)_t;
        immBin = "xxxxx";
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    int _length = immBin.length();
    boolean _greaterThan = (_length > bitLength);
    if (_greaterThan) {
      int _length_1 = immBin.length();
      int _minus = (_length_1 - bitLength);
      int _length_2 = immBin.length();
      String _substring_1 = immBin.substring(_minus, _length_2);
      immBin = _substring_1;
    } else {
      while (((immBin.length() - bitLength) < 0)) {
        immBin = ("0" + immBin);
      }
    }
    return immBin;
  }
  
  /**
   * Helper method to convert binary into hex string.
   * 
   * @param bin - The binary string
   */
  private String binToHex(final String bin) {
    String hex = "";
    boolean _or = false;
    int _length = bin.length();
    boolean _equals = (_length == 16);
    if (_equals) {
      _or = true;
    } else {
      int _length_1 = bin.length();
      boolean _equals_1 = (_length_1 == 32);
      _or = _equals_1;
    }
    if (_or) {
      try {
        long binLong = Long.parseLong(bin, 2);
        String _string = Long.toString(binLong, 16);
        hex = _string;
        while ((hex.length() < (bin.length() / 4))) {
          hex = ("0" + hex);
        }
      } catch (final Throwable _t) {
        if (_t instanceof NumberFormatException) {
          final NumberFormatException e = (NumberFormatException)_t;
          int _length_2 = bin.length();
          boolean _equals_2 = (_length_2 == 16);
          if (_equals_2) {
            hex = "xxxx";
          } else {
            hex = "xxxxxxxx";
          }
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
    }
    return hex;
  }
}
