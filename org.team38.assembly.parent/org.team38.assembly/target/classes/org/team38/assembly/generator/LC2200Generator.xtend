/*
 * generated by Xtext 2.9.1
 */
package org.team38.assembly.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.team38.assembly.lC2200.Program
import org.team38.assembly.lC2200.Directive
import org.team38.assembly.lC2200.Instruction
import org.team38.assembly.lC2200.NOOPDirective
import org.team38.assembly.lC2200.WordDirective
import org.team38.assembly.lC2200.OInstruction
import org.team38.assembly.lC2200.RInstruction
import org.team38.assembly.lC2200.JInstruction
import org.team38.assembly.lC2200.IInstruction
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import java.util.HashMap;
import org.team38.assembly.lC2200.IInstructionLabelTrans

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class LC2200Generator extends AbstractGenerator {
	private StringBuffer assembledOutput;
	private HashMap<String, Integer> labelTable;
	private int offset;
	private String filename;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		assembledOutput = new StringBuffer()
		labelTable = new HashMap<String, Integer>()
		var e_root = resource.getContents().get(0)
		if (e_root.eClass().getName().equals("Program")) {
			offset = 0
			populateLabels(e_root as Program)
			offset = 0
			compileProgram(e_root as Program)
		}
		filename = resource.toString();
		filename = filename.substring(0, filename.length() - 2) + "bin";
		fsa.generateFile(filename, assembledOutput.toString().trim())
	}
	
	//TODO add collision checks for label
	def populateLabels(Program root) {
		var EList<EObject> lines = root.getLines();
		for(line : lines) {
			if (line.eClass().getName().equals("Directive")) {
				var dir = (line as Directive)
				var label = dir.getLabel()
				if(label != null) {
					var label2 = label.getLabel()
					if (label2 != null) {
						labelTable.put(label2.replace(":",""), offset)
					}
				}
			}
			else if (line.eClass().getName().equals("Instruction")) {
				var instr = (line as Instruction)
				var label = instr.getLabel()
				if(label != null) {
					var label2 = label.getLabel()
					if (label2 !=null) {
						labelTable.put(label2.replace(":",""), offset)
					}
				}
			}
			offset++
		}	
	}
	
	def compileProgram(Program root) {
		var EList<EObject> lines = root.getLines();
		for(line : lines) {
			if (line.eClass().getName().equals("Directive")) {
				compileDirective(line as Directive)
			}
			else if (line.eClass().getName().equals("Instruction")) {
				compileInstruction(line as Instruction)
			}
			offset++
		}	
	}
	
	def compileDirective(Directive dir) {
		var dirType = dir.getDirective()
			if (dirType.eClass().getName().equals("NOOPDirective")) {
				compileNOOP(dirType as NOOPDirective)
			}
			else if (dirType.eClass().getName().equals("WordDirective")) {
				compileWord(dirType as WordDirective)
			}
	}
	
	def compileInstruction(Instruction instr) {
		var instrType = instr.getInstruction()
			if(instrType.eClass().getName().equals("IInstruction")) {
				compileIInstruction(instrType as IInstruction)
			}
			else if(instrType.eClass().getName().equals("RInstruction")) {
				compileRInstruction(instrType as RInstruction)
			}	
			else if(instrType.eClass().getName().equals("JInstruction")) {
				compileJInstruction(instrType as JInstruction)
			}	
			else if(instrType.eClass().getName().equals("OInstruction")) {
				compileOInstruction(instrType as OInstruction)
			}			
	}
	
	def compileNOOP(NOOPDirective noop) {
		assembledOutput.append('''0000000000000000
		''')
	}
	
	def compileWord(WordDirective word) {		
		var wordImm = word.getImm()
		
		var wordImmBin = immToBinary(wordImm, 16)
		assembledOutput.append('''«wordImmBin»
		''')
	}
	
	def compileIInstruction(IInstruction iInstr) {
		var op = iInstr.getI_opcode()
		var reg1 = iInstr.getReg1()
		var reg2 = iInstr.getReg2()
		var imm = iInstr.getImm()
		var label = iInstr.getLabel()
		
		var opBin = opToBinary(op.toString())
		var reg1Bin = regToBinary(reg1.toString())
		var reg2Bin = regToBinary(reg2.toString())
		var immBin = ""
		var op_code = ""
		
		if (op instanceof IInstructionLabelTrans) {
			op_code = (op as IInstructionLabelTrans).getI_opcode().toString()	
		}
		
		
		if(op_code.equals("beq")) {
			if (label != null) {
				var label2 = label.getLabel()
				if (label2 != null) {
					var labelLine = labelTable.get(label2)
					if(labelLine != null) {
						immBin = immToBinary(Integer.toString(labelLine - offset), 5)
					} else {
						immBin = "00000"
					}
				}
			}
			
		} else {
			immBin = immToBinary(imm, 5)
		}		
		
		assembledOutput.append('''«opBin» «reg1Bin» «reg2Bin» «immBin»
		''')
	}
	
	def compileRInstruction(RInstruction rInstr) {
		var op = rInstr.getR_opcode()
		var reg1 = rInstr.getReg1()
		var reg2 = rInstr.getReg2()
		var reg3 = rInstr.getReg3()
		
		var opBin = opToBinary(op.toString())
		var reg1Bin = regToBinary(reg1.toString())
		var reg2Bin = regToBinary(reg2.toString())
		var reg3Bin = regToBinary(reg3.toString())
		
		assembledOutput.append('''«opBin» «reg1Bin» «reg2Bin» «reg3Bin» 0
		''')
	}
	
	def compileJInstruction(JInstruction jInstr) {
		var op = jInstr.getJ_opcode()
		var reg1 = jInstr.getReg1()
		var reg2 = jInstr.getReg2()
		
		var opBin = opToBinary(op.toString())
		var reg1Bin = regToBinary(reg1.toString())
		var reg2Bin = regToBinary(reg2.toString())
		
		assembledOutput.append('''«opBin» «reg1Bin» «reg2Bin» 00000
		''')
	}
	
	def compileOInstruction(OInstruction oInstr) {
		var op = oInstr.getO_opcode()
		
		var opBin = opToBinary(op)
		assembledOutput.append('''«opBin» 00000000000 0
		''')
	}
	
	def opToBinary(String op) {
		switch (op) {
			case "add":
				return "000"
			case "nand":
				return "001"
			case "addi":
				return "010"
			case "lw":
				return "011"
			case "sw":
				return "100"
			case "beq":
				return "101"
			case "jalr":
				return "110"
			case "halt":
				return "111"
			default:
				return ""
		}
	}
	
	def regToBinary(String reg) {
		switch (reg) {
			case "$zero":
				return "0000"
			case "$at":	
				return "0001"
			case "$v0":	
				return "0010"
			case "$a0":	
				return "0011"
			case "$a1":	
				return "0010"
			case "$a2":	
				return "0101"
			case "$t0":	
				return "0110"
			case "$t1":	
				return "0111"
			case"$t2":	
				return "1000"
			case "$s0":	
				return "1001"
			case "$s1":	
				return "1010"
			case "$s2":	
				return "1011"
			case"$k0":	
				return "1100"
			case "$sp":
				return "1101"	
			case "$fp":	
				return "1110"
			case "$ra":
				return "1111"
			default:
				return ""
		}
	}
	
	//TODO bounds checking to make sure within 5 bits
	def immToBinary(String imm, int bitLength) {
		var immBin = Integer.toBinaryString(Integer.parseInt(imm))

		if(immBin.length() > bitLength) {
			immBin = immBin.substring(immBin.length()-bitLength, immBin.length())
		}
		else {
			while(immBin.length() - bitLength < 0) {
				immBin = "0" + immBin
			}
		}
		return immBin
		
	}
	

    
}
