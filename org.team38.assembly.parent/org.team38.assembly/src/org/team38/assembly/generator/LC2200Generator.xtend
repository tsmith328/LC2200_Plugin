/*
 * generated by Xtext 2.9.1
 */
package org.team38.assembly.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.team38.assembly.lC2200.Program
import org.team38.assembly.lC2200.Directive
import org.team38.assembly.lC2200.Instruction
import org.team38.assembly.lC2200.NOOPDirective
import org.team38.assembly.lC2200.WordDirective
import org.team38.assembly.lC2200.LADirective
import org.team38.assembly.lC2200.OInstruction
import org.team38.assembly.lC2200.RInstruction
import org.team38.assembly.lC2200.JInstruction
import org.team38.assembly.lC2200.IInstruction
import org.team38.assembly.lC2200.RInstructionTrans
import org.team38.assembly.lC2200.IInstructionImmTrans
import org.team38.assembly.lC2200.IInstructionOffsetTrans
import org.team38.assembly.lC2200.IInstructionLabelTrans
import org.team38.assembly.lC2200.JInstructionTrans
import org.team38.assembly.lC2200.RegTrans
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import java.util.HashMap;

/**
 * Generates binary output from the assembled instructions
 * 
 */
class LC2200Generator extends AbstractGenerator {
	/**
	 * A buffer which will accumulate the generated binary
	 */
	private StringBuffer assembledOutput;
	
	/**
	 * A hash map storing the location of all labels for calculating branches
	 */
	private HashMap<String, Integer> labelTable;
	
	/**
	 * An integer used to keep track of current line being assembled
	 */
	private int offset;
	
	/**
	 * The name of the generated file
	 */
	private String filename;

	/**
	 * doGenerate is called when user saves their assembly code and will
	 * save generated binary output to a file. The code is scanned to obtain
	 * label locations, and then compiled line by line.
	 * 
	 * @param resource
	 * @param fsa
	 * @param context
	 */
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		assembledOutput = new StringBuffer()
		labelTable = new HashMap<String, Integer>()
		var e_root = resource.getContents().get(0)
		if (e_root.eClass().getName().equals("Program")) {
			offset = 0
			populateLabels(e_root as Program)
			offset = 0
			compileProgram(e_root as Program)
		}
		filename = resource.toString();
		filename = filename.substring(0, filename.length() - 2) + "bin";
		fsa.generateFile(filename, assembledOutput.toString().trim())
	}
	
	/**
	 * Stores labels and their position into a hash map
	 * 
	 * @param root
	 */
	def populateLabels(Program root) {
		var EList<EObject> lines = root.getLines();
		for(line : lines) {
			if (line.eClass().getName().equals("Directive")) {
				var dir = (line as Directive)
				var labelBeg = dir.getLabel()
				if(labelBeg != null) {
					var label = labelBeg.getLabel()
					if (label != null) {
						labelTable.put(label.replace(":",""), offset)
					}
				}
			}
			else if (line.eClass().getName().equals("Instruction")) {
				var instr = (line as Instruction)
				var labelBeg = instr.getLabel()
				if(labelBeg != null) {
					var label = labelBeg.getLabel()
					if (label !=null) {
						labelTable.put(label.replace(":",""), offset)
					}
				}
			}
			offset++
		}	
	}
	
	def compileProgram(Program root) {
		var EList<EObject> lines = root.getLines();
		for(line : lines) {
			if (line.eClass().getName().equals("Directive")) {
				compileDirective(line as Directive)
			}
			else if (line.eClass().getName().equals("Instruction")) {
				compileInstruction(line as Instruction)
			}
			offset++
		}	
	}
	
	def compileDirective(Directive dir) {
		var dirType = dir.getDirective()
			if (dirType.eClass().getName().equals("NOOPDirective")) {
				compileNOOP(dirType as NOOPDirective)
			}
			else if (dirType.eClass().getName().equals("WordDirective")) {
				compileWord(dirType as WordDirective)
			}
			else if (dirType.eClass().getName().equals("LADirective")) {
				compileLA(dirType as LADirective)
			}
	}
	
	def compileInstruction(Instruction instr) {
		var instrType = instr.getInstruction()
			if(instrType.eClass().getName().equals("IInstruction")) {
				compileIInstruction(instrType as IInstruction)
			}
			else if(instrType.eClass().getName().equals("RInstruction")) {
				compileRInstruction(instrType as RInstruction)
			}	
			else if(instrType.eClass().getName().equals("JInstruction")) {
				compileJInstruction(instrType as JInstruction)
			}	
			else if(instrType.eClass().getName().equals("OInstruction")) {
				compileOInstruction(instrType as OInstruction)
			}			
	}
	
	def compileLA(LADirective la) {
		var labelTrans = la.getLabel()
		var regTrans = la.getReg()
		var reg = regTrans.getReg()
		var immBin = ""
		if (labelTrans != null) {
			var label = labelTrans.getLabel()
			if (label != null) {
				var labelLine = labelTable.get(label)
				if(labelLine != null) {
					immBin = immToBinary(Integer.toString(labelLine), 5)
				} else {
					immBin = "00000"
				}
			}
		}
		var reg1Bin = regToBinary(reg)
		var reg2Bin = regToBinary("$zero")
		var opBin = opToBinary("addi")
		
		assembledOutput.append('''«opBin» «reg1Bin» «reg2Bin» «immBin»
		''')
		
	}
	
	def compileNOOP(NOOPDirective noop) {
		assembledOutput.append('''0000000000000000
		''')
	}
	
	def compileWord(WordDirective word) {		
		var wordImm = word.getImm()
		
		var wordImmBin = immToBinary(wordImm, 16)
		assembledOutput.append('''«wordImmBin»
		''')
	}
	
	def compileIInstruction(IInstruction iInstr) {
		var opTrans = iInstr.getI_opcode()
		var op = ""
		if(opTrans instanceof IInstructionImmTrans) {
			op = (opTrans as IInstructionImmTrans).getI_opcode()	
		} else if(opTrans instanceof IInstructionOffsetTrans) {
			op = (opTrans as IInstructionOffsetTrans).getI_opcode()
		}		
		else if (opTrans instanceof IInstructionLabelTrans){
			op = (opTrans as IInstructionLabelTrans).getI_opcode()
		}
		var reg1Trans = iInstr.getReg1()
		var reg1 = (reg1Trans as RegTrans).getReg()
		var reg2Trans = iInstr.getReg2()
		var reg2 = (reg2Trans as RegTrans).getReg()
		var imm = iInstr.getImm()
		var labelTrans = iInstr.getLabel()
		
		var opBin = opToBinary(op.toString())
		var reg1Bin = regToBinary(reg1.toString())
		var reg2Bin = regToBinary(reg2.toString())
		var immBin = ""
		
		if(op.equals("beq")) {
			if (labelTrans != null) {
				var label = labelTrans.getLabel()
				if (label != null) {
					var labelLine = labelTable.get(label)
					if(labelLine != null) {
						immBin = immToBinary(Integer.toString(labelLine - offset), 5)
					} else {
						immBin = "00000"
					}
				}
			}
			
		} else {
			immBin = immToBinary(imm, 5)
		}		
		
		assembledOutput.append('''«opBin» «reg1Bin» «reg2Bin» «immBin»
		''')
	}
	
	def compileRInstruction(RInstruction rInstr) {
		var opTrans = rInstr.getR_opcode()
		var op = (opTrans as RInstructionTrans).getR_opcode()
		var reg1Trans = rInstr.getReg1()
		var reg1 = (reg1Trans as RegTrans).getReg()
		var reg2Trans = rInstr.getReg2()
		var reg2 = (reg2Trans as RegTrans).getReg()
		var reg3Trans = rInstr.getReg3()
		var reg3 = (reg3Trans as RegTrans).getReg()
		
		var opBin = opToBinary(op.toString())
		var reg1Bin = regToBinary(reg1.toString())
		var reg2Bin = regToBinary(reg2.toString())
		var reg3Bin = regToBinary(reg3.toString())
		
		assembledOutput.append('''«opBin» «reg1Bin» «reg2Bin» «reg3Bin» 0
		''')
	}
	
	def compileJInstruction(JInstruction jInstr) {
		var opTrans = jInstr.getJ_opcode()
		var op = (opTrans as JInstructionTrans).getJ_opcode()
		var reg1Trans = jInstr.getReg1()
		var reg1 = (reg1Trans as RegTrans).getReg()
		var reg2Trans = jInstr.getReg2()
		var reg2 = (reg2Trans as RegTrans).getReg()
		
		var opBin = opToBinary(op.toString())
		var reg1Bin = regToBinary(reg1.toString())
		var reg2Bin = regToBinary(reg2.toString())
		
		assembledOutput.append('''«opBin» «reg1Bin» «reg2Bin» 00000
		''')
	}
	
	def compileOInstruction(OInstruction oInstr) {
		var op = oInstr.getO_opcode()
		
		var opBin = opToBinary(op)
		assembledOutput.append('''«opBin» 00000000000 0
		''')
	}
	
	def opToBinary(String op) {
		switch (op) {
			case "add":
				return "000"
			case "nand":
				return "001"
			case "addi":
				return "010"
			case "lw":
				return "011"
			case "sw":
				return "100"
			case "beq":
				return "101"
			case "jalr":
				return "110"
			case "halt":
				return "111"
			default:
				return ""
		}
	}
	
	def regToBinary(String reg) {
		switch (reg) {
			case "$zero":
				return "0000"
			case "$at":	
				return "0001"
			case "$v0":	
				return "0010"
			case "$a0":	
				return "0011"
			case "$a1":	
				return "0010"
			case "$a2":	
				return "0101"
			case "$t0":	
				return "0110"
			case "$t1":	
				return "0111"
			case"$t2":	
				return "1000"
			case "$s0":	
				return "1001"
			case "$s1":	
				return "1010"
			case "$s2":	
				return "1011"
			case"$k0":	
				return "1100"
			case "$sp":
				return "1101"	
			case "$fp":	
				return "1110"
			case "$ra":
				return "1111"
			default:
				return ""
		}
	}
	
	//TODO bounds checking to make sure within 5 bits
	def immToBinary(String imm, int bitLength) {
		var immBin = Integer.toBinaryString(Integer.parseInt(imm))

		if(immBin.length() > bitLength) {
			immBin = immBin.substring(immBin.length() - bitLength, immBin.length())
		}
		else {
			while(immBin.length() - bitLength < 0) {
				immBin = "0" + immBin
			}
		}
		return immBin
		
	}
	

    
}
